/**
 * The Abiquo Platform
 * Cloud management application for hybrid clouds
 * Copyright (C) 2008 - Abiquo Holdings S.L.
 *
 * This application is free software; you can redistribute it and/or
 * modify it under the terms of the GNU LESSER GENERAL PUBLIC
 * LICENSE as published by the Free Software Foundation under
 * version 3 of the License
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * LESSER GENERAL PUBLIC LICENSE v.3 for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */
package com.abiquo.bond.api;

import static com.abiquo.bond.api.util.DateUtils.fromDate;
import static com.abiquo.event.model.enumerations.EntityAction.VIRTUAL_MACHINE.UNDEPLOY;

import java.time.LocalDateTime;
import java.time.ZonedDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.ws.rs.client.Invocation;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Response;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.abiquo.bond.api.event.APIEvent;
import com.abiquo.bond.api.event.BackupVMEvent;
import com.abiquo.bond.api.event.DeployVMEvent;
import com.abiquo.bond.api.event.UndeployVMEvent;
import com.abiquo.bond.api.event.VirtualMachineEvent;
import com.abiquo.model.rest.RESTLink;
import com.abiquo.server.core.cloud.MetadataDto;
import com.abiquo.server.core.event.EventDto;
import com.abiquo.server.core.event.EventsDto;
import com.google.common.base.Optional;

/**
 * An instance of this class handles the reading of events from the Abiquo Event Store when the
 * client first starts up in order to process any events missed whilst the client was not running.
 * <p>
 * Because the client can also be used to update the Abiquo server and these updates could generate
 * outbound api events, a dedicated user must be used to connect to the Outbound API ('M') server.
 * Any received events generated by this user can then be ignored.
 */
public class EventStore extends APIConnection
{
    private final static Logger logger = LoggerFactory.getLogger(EventStore.class);

    private NameToVMLinks mapNameToVMLinks;

    private WebTarget targetEventBase;

    private LocalDateTime msgTimeLimit = LocalDateTime.now();

    private int currUserEnterpriseId = -1;

    private int currUserId;

    private Map<String, String> startActions = new HashMap<>();

    /**
     * Sets up a connection to the Abiquo standard API and obtains the id and enterprise id of the
     * dedicated user.
     * 
     * @param server Name or ip address of 'M' server
     * @param user Name of dedicated user
     * @param password Password of dedicated user
     * @param currUserEditLink URL of standard API request to obtain current user details.
     * @param mapNameToVMLinks mapping of virtual machine names to REST URLs which can be used to
     *            request associated data
     */
    public EventStore(final String server, final String user, final String password,
        final RESTLink currUserEditLink, final NameToVMLinks mapNameToVMLinks)
    {
        super(server, user, password);
        targetEventBase = targetAPIBase.path("events");
        currUserId = currUserEditLink.getId();
        logger.debug("Current User ID: {}", currUserId);
        String href = currUserEditLink.getHref();
        String startMarker = "/enterprises/";
        int idxEnterpriseIdStart = href.lastIndexOf(startMarker);
        if (idxEnterpriseIdStart >= 0)
        {
            idxEnterpriseIdStart += startMarker.length();
            int idxEnterpriseIdEnd = href.lastIndexOf("/users/");
            if (idxEnterpriseIdEnd >= 0)
            {
                String entid = href.substring(idxEnterpriseIdStart, idxEnterpriseIdEnd);
                currUserEnterpriseId = Integer.parseInt(entid);
                logger.debug("Current User Enterprise ID: {}", currUserEnterpriseId);
            }
        }
        this.mapNameToVMLinks = mapNameToVMLinks;
    }

    /**
     * Sets the date at after which we no longer need events. This should be the time and date at
     * which the connection to the Outbound API was established.
     */
    public void setMsgTimeLimit()
    {
        msgTimeLimit = LocalDateTime.now();
        logger.debug("Only processing messages before: {}", msgTimeLimit);
    }

    /**
     * Fetches events from the Event Store in batches of 1000 , processes them into APIEvents and
     * passes them to the appropriate event handler.
     * 
     * @param startdate earliest date for which we need events
     * @param handler reference to APIEvent handler
     * @throws OutboundAPIClientHTTPException
     */
    public void getMissedEvents(final LocalDateTime startdate, final EventStoreHandler handler)
        throws OutboundAPIClientHTTPException
    {
        logger.debug("Only processing messages after: {}", startdate);

        String limitdate = Long.toString(startdate.toEpochSecond(ZonedDateTime.now().getOffset()));

        WebTarget targetVMsOnly =
            targetEventBase.queryParam("limit", "10").queryParam("asc", "true")
                .queryParam("datefrom", limitdate);

        boolean moreevents = true;
        while (moreevents)
        {
            Invocation.Builder invocationBuilder = targetVMsOnly.request(EventsDto.MEDIA_TYPE);
            Response response = invocationBuilder.get();
            int status = response.getStatus();
            if (status == 200)
            {
                EventsDto resourceObject = response.readEntity(EventsDto.class);

                List<EventDto> events = resourceObject.getCollection();
                for (EventDto event : events)
                {
                    LocalDateTime eventDate = fromDate(event.getTimestamp());
                    if (eventDate.isBefore(msgTimeLimit))
                    {
                        logger.debug(
                            "Processing event: ts:{} component:{} action:{}",
                            new Object[] {event.getTimestamp(), event.getComponent(),
                            event.getActionPerformed()});
                        String component = event.getComponent();
                        if (component != null)
                        {
                            if (component.equalsIgnoreCase("VIRTUAL_MACHINE"))
                            {
                                VirtualMachineProcessor vmp = new VirtualMachineProcessor();
                                Optional< ? extends VirtualMachineEvent> optvmevent =
                                    vmp.processEvent(event);
                                if (optvmevent.isPresent())
                                {
                                    handler.handleMessage(optvmevent.get());
                                }
                            }
                            else
                            {
                                handler.handleMessage(new APIEvent(event));
                            }
                        }
                    }
                    else
                    {
                        logger.debug("Event from after time limit received");
                        return;
                    }
                }

                moreevents = false;
                RESTLink nextlink = resourceObject.searchLink("next");
                if (nextlink != null)
                {
                    targetVMsOnly =
                        client.target(nextlink.getHref()).queryParam("asc", "true")
                            .queryParam("datefrom", limitdate);
                    moreevents = true;
                }
            }
            else
            {
                throw new OutboundAPIClientHTTPException("Failed to fetch messages",
                    targetVMsOnly.getUri(),
                    status);
            }
        }
    }

    private Optional<MetadataDto> getMetaData(final EventDto event)
    {
        Optional<RESTLink> optMetadataLink =
            mapNameToVMLinks.getLink(event.getVirtualMachine(), NameToVMLinks.VM_LINK_METADATA);
        if (optMetadataLink.isPresent())
        {
            RESTLink metadataLink = optMetadataLink.get();
            WebTarget targetMetaData = client.target(metadataLink.getHref());
            Invocation.Builder invocationBuilderMeta =
                targetMetaData.request(MetadataDto.MEDIA_TYPE);
            Response responseMeta = invocationBuilderMeta.get();
            int statusMeta = responseMeta.getStatus();
            if (statusMeta == 200)
            {
                return Optional.of(responseMeta.readEntity(MetadataDto.class));
            }
            else
            {
                logger.error("HTTP error {} retrieving backup event metadata.", statusMeta);
            }
        }
        return Optional.absent();
    }

    /**
     * Handle events related to virtual machines. This has been put into its own class as the
     * getMissedEvents method will get very long once we add support for other event types.
     */
    class VirtualMachineProcessor
    {
        Optional< ? extends VirtualMachineEvent> processEvent(final EventDto event)
        {
            String action = event.getActionPerformed().toUpperCase();
            Optional< ? extends VirtualMachineEvent> optvmevent = Optional.absent();
            Optional<MetadataDto> optMetaData = getMetaData(event);
            if (action.equals("VIRTUAL_MACHINE_METADATA_MODIFIED"))
            {
                Integer eventUserId = event.getIdUser();
                Integer eventEnterpriseId = event.getIdEnterprise();

                if (eventUserId == null || eventEnterpriseId == null || currUserId != eventUserId
                    && currUserEnterpriseId != eventEnterpriseId)
                {
                    optvmevent = Optional.of(new BackupVMEvent(event, optMetaData));
                }
                else
                {
                    logger
                        .debug("Skipped virtual machine backup event generated by dedicated user.");
                }
            }
            else if (action.equals("VIRTUAL_MACHINE_CREATE")
                || action.equals("VIRTUAL_MACHINE_UNDEPLOY"))
            {
                startActions.put(event.getVirtualMachine(), action);
            }
            else if (action.equals("VIRTUAL_MACHINE_DEPLOY_FINISH"))
            {
                // Both deploys and undeploys currently finish with an
                // DEPLOY_FINISH action, so
                // until that bug (ABICLOUDPREMIUM-6135) is fixed we need to
                // check what the original
                // action was
                String vmname = event.getVirtualMachine();
                String originalaction = startActions.get(vmname);
                if (action.equals("VIRTUAL_MACHINE_DEPLOY_FINISH")
                    && UNDEPLOY.action().equalsIgnoreCase(originalaction))
                {
                    optvmevent = Optional.of(new UndeployVMEvent(event));
                }
                else
                {
                    optvmevent = Optional.of(new DeployVMEvent(event, optMetaData));
                }
            }
            else if (action.equals("VIRTUAL_MACHINE_UNDEPLOY_FINISH"))
            {
                optvmevent = Optional.of(new UndeployVMEvent(event));
            }
            else
            {
                optvmevent = Optional.of(new VirtualMachineEvent(event, optMetaData));
            }
            return optvmevent;
        }
    }
}
